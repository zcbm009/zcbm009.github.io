<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>DOCKER--镜像与容器操作--复习一 - zcbm-blog</title><meta name="description" content="基础概念 容器化技术 Docker是容器技术中的佼佼者。 虚拟化可以通过硬件模拟来实现，也可以通过操作系统软件来实现，而容器技术则利用操作系统本身的机制与特性，实现远超传统虚拟化的轻量级虚拟化。 虚拟化（virtualization）技术是一个通用的概念，在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化（computing virtualization），或通常说的服务器虚拟化。 虚拟化的核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且带来降低成本、方便管理和容错容灾等好处。 从大类上分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化； 基于软件的虚拟化从对象所在的层次，又可以分为应用虚拟化和平台虚拟化（完全虚拟化、硬件辅助虚拟化、部分虚拟化、超虚拟化、操作系统虚拟化–Docker就是属于这类，操作系统虚拟化最大的特点就是不需要额外的supervisor支持）。 传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层（这里有个传统虚拟化与Docker虚拟化的对比图）。Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。 容器化技术与虚拟化技术之间就像这样一个关系：中国与其他国家在中国创建的大使馆（虚拟化技术），中国与内蒙古自治区、香港澳门台湾一国两制（容器化技术）。 基于Go语言实现的开源容器项目； 诞生于2013年年初，发起者是dotCloud公司，拥有众多相关开源组件项目，逐渐生成了围绕Docker容器的完整生态体系，2013年改名为DockerInc，并专注于Docker相关技术与产品的开发，目前已经成为全球最大的Docker容器服务提供商，官方网站为docker.com。 Docker项目代码开源在Github上，遵循Apache 2.0协议。 Docker的构想是要实现“Build, Ship and Run Any App, Anywhere”，即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。 Linux容器（Linux&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://zcbm009.github.io/docker-jing-xiang-yu-rong-qi-cao-zuo-fu-xi-yi.html"><link rel="alternate" type="application/atom+xml" href="https://zcbm009.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://zcbm009.github.io/feed.json"><meta property="og:title" content="DOCKER--镜像与容器操作--复习一"><meta property="og:image" content="https://zcbm009.github.io/media/website/60418745_p0_master1200.jpg"><meta property="og:site_name" content="zcbm-blog"><meta property="og:description" content="基础概念 容器化技术 Docker是容器技术中的佼佼者。 虚拟化可以通过硬件模拟来实现，也可以通过操作系统软件来实现，而容器技术则利用操作系统本身的机制与特性，实现远超传统虚拟化的轻量级虚拟化。 虚拟化（virtualization）技术是一个通用的概念，在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化（computing virtualization），或通常说的服务器虚拟化。 虚拟化的核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且带来降低成本、方便管理和容错容灾等好处。 从大类上分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化； 基于软件的虚拟化从对象所在的层次，又可以分为应用虚拟化和平台虚拟化（完全虚拟化、硬件辅助虚拟化、部分虚拟化、超虚拟化、操作系统虚拟化–Docker就是属于这类，操作系统虚拟化最大的特点就是不需要额外的supervisor支持）。 传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层（这里有个传统虚拟化与Docker虚拟化的对比图）。Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。 容器化技术与虚拟化技术之间就像这样一个关系：中国与其他国家在中国创建的大使馆（虚拟化技术），中国与内蒙古自治区、香港澳门台湾一国两制（容器化技术）。 基于Go语言实现的开源容器项目； 诞生于2013年年初，发起者是dotCloud公司，拥有众多相关开源组件项目，逐渐生成了围绕Docker容器的完整生态体系，2013年改名为DockerInc，并专注于Docker相关技术与产品的开发，目前已经成为全球最大的Docker容器服务提供商，官方网站为docker.com。 Docker项目代码开源在Github上，遵循Apache 2.0协议。 Docker的构想是要实现“Build, Ship and Run Any App, Anywhere”，即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。 Linux容器（Linux&hellip;"><meta property="og:url" content="https://zcbm009.github.io/docker-jing-xiang-yu-rong-qi-cao-zuo-fu-xi-yi.html"><meta property="og:type" content="article"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link href="https://fonts.googleapis.com/css?family=Muli:400,400i,600&amp;subset=latin-ext&amp;display=swap" rel="stylesheet"><style>:root{--primary-font:'Muli',sans-serif;--secondary-font:'Muli',sans-serif}</style><link rel="stylesheet" href="https://zcbm009.github.io/assets/css/fontawesome-all.min.css?v=dbf9d822cefe851ba6f66e1ad57e8987"><link rel="stylesheet" href="https://zcbm009.github.io/assets/css/style.css?v=7ee58c4cb701abe27098e32edf12e177"><noscript><link rel="stylesheet" href="https://zcbm009.github.io/assets/css/noscript.css?v=6228c7eee614cd200a2cad8333b439fa"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://zcbm009.github.io/docker-jing-xiang-yu-rong-qi-cao-zuo-fu-xi-yi.html"},"headline":"DOCKER--镜像与容器操作--复习一","datePublished":"2021-12-02T17:02","dateModified":"2021-12-02T17:02","image":{"@type":"ImageObject","url":"https://zcbm009.github.io/media/website/60418745_p0_master1200.jpg","height":1200,"width":1091},"description":"基础概念 容器化技术 Docker是容器技术中的佼佼者。 虚拟化可以通过硬件模拟来实现，也可以通过操作系统软件来实现，而容器技术则利用操作系统本身的机制与特性，实现远超传统虚拟化的轻量级虚拟化。 虚拟化（virtualization）技术是一个通用的概念，在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化（computing virtualization），或通常说的服务器虚拟化。 虚拟化的核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且带来降低成本、方便管理和容错容灾等好处。 从大类上分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化； 基于软件的虚拟化从对象所在的层次，又可以分为应用虚拟化和平台虚拟化（完全虚拟化、硬件辅助虚拟化、部分虚拟化、超虚拟化、操作系统虚拟化–Docker就是属于这类，操作系统虚拟化最大的特点就是不需要额外的supervisor支持）。 传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层（这里有个传统虚拟化与Docker虚拟化的对比图）。Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。 容器化技术与虚拟化技术之间就像这样一个关系：中国与其他国家在中国创建的大使馆（虚拟化技术），中国与内蒙古自治区、香港澳门台湾一国两制（容器化技术）。 基于Go语言实现的开源容器项目； 诞生于2013年年初，发起者是dotCloud公司，拥有众多相关开源组件项目，逐渐生成了围绕Docker容器的完整生态体系，2013年改名为DockerInc，并专注于Docker相关技术与产品的开发，目前已经成为全球最大的Docker容器服务提供商，官方网站为docker.com。 Docker项目代码开源在Github上，遵循Apache 2.0协议。 Docker的构想是要实现“Build, Ship and Run Any App, Anywhere”，即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。 Linux容器（Linux&hellip;","author":{"@type":"Person","name":"zcbm"},"publisher":{"@type":"Organization","name":"zcbm","logo":{"@type":"ImageObject","url":"https://zcbm009.github.io/media/website/60418745_p0_master1200.jpg","height":1200,"width":1091}}}</script><style>#wrapper > .bg {
               background-image: url(https://zcbm009.github.io/assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(https://zcbm009.github.io/media/website/1641459510380.jpeg);
           }</style></head><body class="is-preload"><div id="wrapper"><header id="header"><a class="logo logo-image" href="https://zcbm009.github.io/"><img src="https://zcbm009.github.io/media/website/60418745_p0_master1200.jpg" alt="zcbm-blog"></a></header><nav id="nav"><ul class="links"><li><a href="https://zcbm009.github.io/tags/" target="_self">TAGS</a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2021-12-02T17:02" class="date">十二月 2, 2021</time><h1>DOCKER--镜像与容器操作--复习一</h1><p class="post__inner"></p></header><div class="post__inner post__entry"><h3 id="基础概念">基础概念</h3><h4 id="容器化技术">容器化技术</h4><hr><p>Docker是容器技术中的佼佼者。</p><hr><h4 id="虚拟化技术">虚拟化技术</h4><hr><h5 id="虚拟化与容器技术之间的区别">虚拟化与容器技术之间的区别</h5><p>虚拟化可以通过硬件模拟来实现，也可以通过操作系统软件来实现，而容器技术则利用操作系统本身的机制与特性，实现远超传统虚拟化的轻量级虚拟化。</p><h5 id="什么是虚拟化技术">什么是虚拟化技术</h5><p>虚拟化（virtualization）技术是一个通用的概念，在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化（computing virtualization），或通常说的服务器虚拟化。</p><p>虚拟化的核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且带来降低成本、方便管理和容错容灾等好处。</p><h5 id="虚拟化技术的分类">虚拟化技术的分类</h5><p>从大类上分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化；</p><p>基于软件的虚拟化从对象所在的层次，又可以分为应用虚拟化和平台虚拟化（完全虚拟化、硬件辅助虚拟化、部分虚拟化、超虚拟化、操作系统虚拟化–Docker就是属于这类，操作系统虚拟化最大的特点就是不需要额外的supervisor支持）。</p><p>传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层（这里有个传统虚拟化与Docker虚拟化的对比图）。Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。</p><h5 id="自评">自评</h5><p>容器化技术与虚拟化技术之间就像这样一个关系：中国与其他国家在中国创建的大使馆（虚拟化技术），中国与内蒙古自治区、香港澳门台湾一国两制（容器化技术）。</p><hr><h4 id="docker的发展历史">Docker的发展历史</h4><hr><p>基于Go语言实现的开源容器项目；</p><h5 id="开发商的发展">开发商的发展</h5><p>诞生于2013年年初，发起者是<code>dotCloud</code>公司，拥有众多相关开源组件项目，逐渐生成了围绕Docker容器的完整生态体系，2013年改名为<code>DockerInc</code>，并专注于Docker相关技术与产品的开发，目前已经成为全球最大的Docker容器服务提供商，官方网站为docker.com。</p><p>Docker项目代码开源在<code>Github</code>上，遵循Apache 2.0协议。</p><h5 id="docker理念">Docker理念</h5><p>Docker的构想是要实现“Build, Ship and Run Any App, Anywhere”，即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。</p><h5 id="支撑技术的发展">支撑技术的发展</h5><p>Linux容器（Linux Containers, LXC）技术。IBM <code>DeveloperWorks</code>网站关于容器技术的描述十分准确：“容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，而不需要任何专门的解释机制。此外，也避免了准虚拟化（para-virtualization）和系统调用替换中的复杂性。”（从小圈子使用到成为Linux系统轻量级容器技术的事实标准。）</p><p>在LXC的基础上，Docker提供了各种容器管理工具，让用户无须关注底层操作，引入分层文件系统构建和高效的镜像机制，降低了迁移难度；自0.9版本开始，Docker开发了libcon-tainer项目作为更广泛的容器驱动实现，从而替<u>换掉了LXC的实现</u>。Docker还积极推动成立了runC标准项目，并贡献给开放容器联盟，试图让容器的支持不再局限于Linux操作系统，而是更安全、更开放、更具扩展性。</p><hr><h4 id="docker的三大内容">Docker的三大内容</h4><h5 id="docker的三大内容都是哪些，简单概括一下">Docker的三大内容都是哪些，简单概括一下</h5><p>三大内容有镜像、容器、仓库。</p><p>镜像有几大点：静态只读、创建容器、可以包含操作系统及依赖于此的应用程序；</p><p>容器有几大点：运行与隔离应用、容器之间可以通过网络互相访问；</p><p>仓库有几大点：注册中心与Docker创建之间的关系、公有仓库与私有仓库；</p><h5 id="镜像">镜像</h5><p><u>首先回答基本命令：镜像的增、删、改、查</u></p><p><strong>常用命令一</strong></p><p><u>添加</u>（获取）镜像的命令：docker pull imageName；</p><p>镜像名称的组成：仓库名称+标签；</p><p>镜像重名：同一个仓库中重名则根据版本号来区分，如果不同仓库则根据仓库ip地址来区分，不写标签会默认从DockerHub中获取最新版本的镜像；</p><p><del>镜像的内容与组成：镜像由若干层组成，唯一id</del></p><p>公有仓库与私有仓库：前者是DockerHub提供的仓库，另外还可以在当前局域网中创建自己的Docker仓库，这点类似于Github。</p><p><strong>常用命令二</strong></p><p><strong>查</strong>看已有的镜像的基本信息：docker images/docker image ls;</p><p>可以查看的基本信息有：name tag size image-id created;</p><p>查看帮助文件：man docker-images;</p><p><strong>常用命令三</strong></p><p>为镜像添加别名：docker tag oldName newName，添加别名结果可从docker images 查看；</p><p><em>这个命令类似windows的桌面快捷方式，linux的link文件，git的提交内容版本标签</em></p><p><strong>常用命令四</strong></p><p>查看一个镜像的详细信息：docker inspect imageName；</p><p>查看一个镜像历史信息：docker history imageName；</p><p><strong>常用命令五</strong></p><p>从仓库中<u>搜索</u>镜像：docker search imageName；</p><p><strong>常用命令六</strong></p><p><u>删除</u>镜像：docker rmi id/tag–如果是镜像id则会先删除镜像相关的标签，然后再删除镜像，如果是标签的话则就会直接删除标签，镜像不会产生影响；</p><p><em>在删除镜像前，会先查看是否存在与镜像对应的容器，如果存在可以使用-f关键字强制删除镜像，否则就只能删除容器后再执行镜像删除操作</em></p><p>删除临时镜像的遗留文件：docker prune；</p><p><strong>常用命令七</strong></p><p>创建镜像的三种方法：基于（已有镜像的）容器创建、基于本地模板导入、基于Dockerfile创建。</p><p><u><em>主要用途是基于当前环境创建镜像并进行环境迁移，以及上传镜像到仓库中</em></u></p><h5 id="容器">容器</h5><p><em>需要掌握有容器的增、删、改、查相关命令</em></p><p><strong>常用命令一</strong></p><p>创建一个容器：<code>docker create imageName</code></p><p>创建容器需要基于镜像；创建后的容器处于停止状态，需要运行其他命令来运行；</p><p><strong>常用命令二</strong></p><p>运行一个容器：<code>docker start container</code></p><p>运行创建的容器</p><p><strong>常用命令三</strong></p><p>创建并运行一个容器：<code>docker run imageName</code></p><p>添加参数<code>-d</code>则创建一个在后台运行的容器；</p><p>如果命令存在可以输入窗口（如bash），则可以添加参数<code>-it</code>保持输入端打开并监听其输入内容；</p><p>是前面两个命令的结合，其中有详细的过程，<u>以后需要将此过程详细的说明出来</u></p><p><strong>常用命令四</strong></p><p>查看正在运行的容器：<code>docker ls/ps</code></p><p><strong>常用命令五</strong></p><p>获取容器的输出信息：<code>docker logs</code></p><p><strong>常用命令六</strong></p><p>容器的暂停与开始：<code>docker pause/unpause container</code></p><p>可以通过pause来暂停容器，处于停止状态的容器可以通过unpause来重新运行容器</p><p><strong>常用命令七</strong></p><p>容器的停止：<code>docker stop container</code></p><p>容器停止的过程：先向容器发送一个SIGTERM信号，十秒后发送一个SINKILL信号，然后容器进入停止状态，也只可以使用<code>docker kill container</code>命令直接发送一个Kill信息给容器；</p><p>容器进入停止状态的可能情况：容器正常运行结束，使用命令，使用ctrl+d或exit退出容器；</p><p>容器处于停止状态时可以再使用start命令来重新运行；</p><p><strong>常用命令八</strong></p><p>删除处于停止状态的容器：<code>docker prune</code></p><p><strong>常用命令九</strong></p><p>重启容器：<code>docker restart container</code></p><p>先使容器进入停止状态，再使重新启动容器</p><p><strong>常用命令十</strong></p><p>进入处于的容器：<code>docker attach container</code> <code>docker exec container</code></p><p>前者可以维持一个输入窗口来与容器交互，但是多个窗口与容器的交互是相同的，所以当一个窗口处于阻塞状态时其他窗口也处于阻塞状态；后者则没有前面的问题，可以直接输入命令运行，可以使用（-it）运行一个伪终端与容器交互。</p><p><strong>常用命令十一</strong></p><p>删除一个容器：<code>docker rm container</code></p><p>为了与镜像操作区分，使用了<code>rm</code>，而镜像使用了<code>rmi</code>，意为rm image；</p><p>默认只能删除处于停止或者退出状态的容器，但是可以使用参数<code>-f</code>参数强制删除容器。</p><p><strong>常用命令十二</strong></p><p>查看容器信息：<code>docker inspect container</code> <code>docker top container</code> <code>docker stats container</code></p><p>这些命令都与linux系统的部分命令类似</p></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on 十二月 2, 2021</p><div class="post__share-tag-container"><div class="post__tag"><h3>Tagged in:</h3><ul><li><a href="https://zcbm009.github.io/tags/book/">Book</a></li><li><a href="https://zcbm009.github.io/tags/docker/">Docker</a></li><li><a href="https://zcbm009.github.io/tags/selfcheckquestion/">SelfCheckQuestion</a></li></ul></div><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"></div></div></div><div class="post__bio"><div><h3><a href="https://zcbm009.github.io/authors/zcbm/" class="invert" rel="author">zcbm</a></h3></div></div></footer></article></main><footer id="copyright"><ul><li>© Massively</li><li>Design: <a href="https://html5up.net" target="_blank" rel="nofollow noopener">HTML5 UP</a></li><li>Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></li></ul></footer></div><script src="https://zcbm009.github.io/assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="https://zcbm009.github.io/assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="https://zcbm009.github.io/assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="https://zcbm009.github.io/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://zcbm009.github.io/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://zcbm009.github.io/assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="https://zcbm009.github.io/assets/js/main.min.js?v=149e72e3ae18744a477b480b19e0c6da"></script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>